package es.uma.lcc.caesium.pedestrian.evacuation.optimization.greedy;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import es.uma.lcc.caesium.ea.util.EAUtil;
import es.uma.lcc.caesium.pedestrian.evacuation.optimization.Double2AccessDecoder;
import es.uma.lcc.caesium.pedestrian.evacuation.optimization.ExitEvacuationProblem;
import es.uma.lcc.caesium.pedestrian.evacuation.simulator.environment.Access;

/**
 * A greedy algorithm to place exits in the best position out of
 * a collection a_0, ..., a_m, where a_0 is randomly chosen and 
 * a_{i+1} = a_i + exit_width (the addition being treated as circular 
 * within the range of the perimeter.
 * @author ccottap
 * @version 1.1 
 */
public class GreedyPerimetralExitPlacement {
	/**
	 * Width of exits in meters
	 */
	private final double exitWidth;
	/**
	 * length of the perimeter
	 */
	private final double perimeterLength;
	/**
	 * number of potential locations for an exit
	 */
	private final int numpos;
	/**
	 * normalized displacement for each potential exit location
	 */
	private final double inc;
	/**
	 * the instance of the evacuation problem
	 */
	private final ExitEvacuationProblem eep;
	/**
	 * decoder of accesses
	 */
	private Double2AccessDecoder decoder;
	/**
	 * verbosityL level (0 = no verbosity)
	 */
	private int verbosityLevel = 0; 
	
	/**
	 * Creates the greedy algorithm
	 * @param eep an exit evacuation problem
	 */
	public GreedyPerimetralExitPlacement(ExitEvacuationProblem eep) {
		this.eep = eep;
		decoder = new Double2AccessDecoder(eep);
		exitWidth = eep.getExitWidth();
		perimeterLength = eep.getPerimeterLength();	
		numpos = (int)Math.ceil(perimeterLength/exitWidth);
		inc = 1.0/numpos;
	}

	/**
	 * Sets the verbosity level
	 * @param verbosityLevel the verbosity level to set
	 */
	public void setVerbosityLevel(int verbosityLevel) {
		this.verbosityLevel = verbosityLevel;
	}

	/**
	 * Finds the location of the next exit (the best out of all the 
	 * candidate exits provided).
	 * @param current the current list of exits
	 * @param candidates the potential locations of the next exit 
	 * @return the location of the next exit
	 */
	public double nextExit(List<Access> current, Collection<Double> candidates) {
		int id = current.size();
		double best = Double.POSITIVE_INFINITY;
		double bestpos = -1;
		if (verbosityLevel > 0) {
			System.out.println("Trying with " + current.size() + " exits...");
			System.out.println("Initial: " + eep.fitness(eep.simulate(current)));
		}
		for (double pos: candidates) {
			double location = pos * perimeterLength;
			List<Access> acc = new ArrayList<Access>(current);
			acc.addAll(decoder.decodeAccess(location, id, id));
			double quality = eep.fitness(eep.simulate(acc));
			if (quality < best) {
				best = quality;
				bestpos = pos;
				if (verbosityLevel > 0)
					System.out.println("New best: " + pos + " (" + best + ") " + acc);
			}
		}
		if (verbosityLevel > 0) {
			System.out.println("Final best: " + bestpos + " (" + best + ")");
			List<Access> acc = new ArrayList<Access>(current);
			acc.addAll(decoder.decodeAccess(bestpos*perimeterLength, id, id));
			System.out.println("Recheck: " + eep.fitness(eep.simulate(acc)) + " " + acc);
		}
		return bestpos;
	}
	
	
	/**
	 * Finds the location of the next exit (the best out of all the 
	 * candidate exits provided).
	 * @param locations the current list of exits (expressed as normalized points in the perimeter)
	 * @param candidates the potential locations of the next exit 
	 * @return the location of the next exit
	 */
	public double next(List<Double> locations, Collection<Double> candidates) {
		List<Access> current = new ArrayList<Access>();
		int id = 0;
	    for (double loc : locations) {
	    	current.addAll(decoder.decodeAccess(loc * perimeterLength, id++, current.size()));
	    }
		return nextExit(current, candidates);
	}
	
	
	/**
	 * Finds the location of the next exit (uses the dafault list of candidates generated by {@link generateAllCandidates}).
	 * @param locations the current list of exits (expressed as normalized points in the perimeter)
	 * @return the location of the next exit
	 * @see generateAllCandidates
	 */
	public double next(List<Double> locations) {
		return next(locations, generateAllCandidates());
	}
	
	/**
	 * Generates a random complete (in the sense of covering the whole perimeter) 
	 * collection of candidates a_0, ..., a_m, where a_0 is randomly chosen and 
	 * a_{i+1} = a_i + exit_width (the addition being treated as circular within 
	 * the range of the perimeter).
	 * @return a collection of candidates
	 */
	private Collection<Double> generateAllCandidates() {
		double pos = EAUtil.random01();
		var candidates = new ArrayList<Double>(numpos);
		for (int i=0; i<numpos; i++) {
			candidates.add(pos);
			pos += inc;
			if (pos > 1)
				pos -= 1.0;
		}
		return candidates;
	}
	
	/**
	 * Greedily finds the position of a number of exits. It considers
	 * a random complete collection of candidates as generated by the 
	 * {@link generateAllCandidates} method.
	 * @param numExits the number of exits to be found
	 * @return the list of encoded locations
	 * @see generateAllCandidates
	 */
	public List<Double> getExits (int numExits) {	
		return getExits (numExits, generateAllCandidates());
	}
	
	
	/**
	 * Greedily finds the position of a number of exits out of
	 * a set of potential candidates.
	 * @param numExits the number of exits to be found
	 * @param candidates the potential location of exits
	 * @return the list of encoded locations
	 */
	public List<Double> getExits (int numExits, Collection<Double> candidates) {
		List<Double> locations = new ArrayList<Double>(numExits);
		List<Access> acc = new ArrayList<Access>(numExits);
		for (int i=0; i<numExits; i++) {
			double next = nextExit (acc, candidates);
			acc.addAll(decoder.decodeAccess(next * perimeterLength, i, acc.size()));
			locations.add(next);
		}
		
		return locations;
	}
	
}
